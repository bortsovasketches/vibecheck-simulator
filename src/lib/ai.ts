import { createGoogleGenerativeAI } from '@ai-sdk/google';
import { generateObject } from 'ai';
import { z } from 'zod';

export type AIProvider = 'google';

export const getAIModel = (apiKey: string) => {
    const google = createGoogleGenerativeAI({
        apiKey,
    });
    // corrected to gemini-3-pro-preview based on docs
    return google('gemini-3-pro-preview');
};

export type ContentMode = 'standard' | 'crisis';

export const generatePersonas = async (content: string, apiKey: string, mode: ContentMode = 'standard') => {
    // MOCK MODE FOR TESTING
    if (apiKey === 'test-key' || apiKey === 'test-key-123' || (apiKey && apiKey.startsWith('test-'))) {
        console.log('Using MOCK MODE for generatePersonas');
        await new Promise(resolve => setTimeout(resolve, 800)); // Simulate delay
        return Array.from({ length: 5 }).map((_, i) => ({
            id: `mock-${i}`,
            name: `Mock Persona ${i + 1}`,
            role: 'Test User',
            description: 'A simulated user for testing purposes.',
            background: 'Generated by mock mode.',
            goals: 'To test the application.',
            painPoints: ['Mock pain point 1', 'Mock pain point 2'],
            archetype: 'Mock Archetype'
        }));
    }

    const model = getAIModel(apiKey);
    const count = 5;

    let systemPrompt = '';
    if (mode === 'crisis') {
        systemPrompt = `You are an expert PR Crisis Manager in a futuristic sci-fi setting. Analyze the content and identify exactly ${count} distinct, critical audience personas who represent potential PR risks.
        Focus on valid critics, skeptics, activists, and journalists who might scrutinize this content.
        IMPORTANT: Generate "Sci-Fi Futurist" names for these personas (e.g., XAe-12, Nova Prime, Kael-7, Orion Pax, Lyra-9). Do NOT use traditional names.
        The personas should be diverse in their criticism (e.g., one focuses on ethics, one on accuracy, one on tone).`;
    } else {
        systemPrompt = `You are an expert Content Strategist & Sociologist in a futuristic sci-fi setting. 
        
        **Step 1: Analyze the Content Ecosystem**
        - First, determine the exact format and community context of the input.
        - Is it an Academic Paper? A Podcast? A Corporate Memo? A Viral Tweet?

        **Step 2: Define Archetypal Roles (CRITICAL)**
        - **If Niche/Structural:** Use specific structural roles.
          - E.g. Academic Paper -> "Reviewer #2", "Grant Committee Chair", "PhD Student".
          - E.g. Code PR -> "Senior Maintainer", "Junior Dev", "Security Auditor".
        - **If General/Broadcast:** Use engagement-based roles.
          - E.g. Podcast -> "Commuter Listener", "Superfan", "Hate-Listener".
          - E.g. News Article -> "Headline Skimmer", "Deep Diver", "Skeptic".

        **Step 3: Construct Profiles**
        1. **Identify the 'Job to be Done'**: What is the reader trying to accomplish?
        2. **Infer Psychographics**: What are their anxieties, values, and worldviews?
        3. **Determine the Stake**: What do they stand to gain or lose?
        4. **Generate Personas**: Create exactly ${count} personas that embody these specific roles.
        
        IMPORTANT: Generate "Sci-Fi Futurist" names for these personas (e.g., XAe-12, Nova Prime).
        The 'role' field must be the archetypal role (e.g. "Reviewer #2"), not a generic job title.`;
    }

    const prompt = `
    Analyze the following content and generate ${count} detailed user personas.
    
    Content Preview:
    ${content.slice(0, 2000)}...
    `;

    const { object: result } = await generateObject({
        model,
        schema: z.object({
            personas: z.array(z.object({
                id: z.string(),
                name: z.string().describe("Space-age futurist name (e.g. XAe-12)"),
                role: z.string().describe("The specific archetype acting on this content (e.g. 'Reviewer #2' or 'Podcast Listener')"),
                description: z.string(),
                background: z.string(),
                goals: z.string(),
                painPoints: z.array(z.string()),
                archetype: z.string().describe("The general category this persona belongs to"),
            })).length(count)
        }),
        prompt: `${systemPrompt}\n${prompt}`,
    });

    return result.personas;
};

export const generateWildcard = async (content: string, apiKey: string) => {
    // MOCK MODE FOR TESTING
    if (apiKey === 'test-key' || apiKey === 'test-key-123' || (apiKey && apiKey.startsWith('test-'))) {
        console.log('Using MOCK MODE for generateWildcard');
        await new Promise(resolve => setTimeout(resolve, 800));
        return {
            id: `wildcard-mock-${Date.now()}`,
            name: 'Mock Wildcard',
            role: 'Chaos Agent',
            description: 'A completely random perspective.',
            background: 'Appeared from the void.',
            goals: 'To disrupt the status quo.',
            painPoints: ['Predictability', 'Boredom'],
            archetype: 'Wildcard'
        };
    }

    const model = getAIModel(apiKey);

    const prompt = `Create 1 "Wildcard" user persona who is completely unrelated to the content's target audience or represents an extreme outlier.
    This person should have a distinct background that leads to a surprising or unconventional perspective.
    
    Content Preview:
    ${content.slice(0, 1000)}...
    `;

    const { object: result } = await generateObject({
        model,
        schema: z.object({
            persona: z.object({
                id: z.string(),
                name: z.string(),
                role: z.string(),
                description: z.string(),
                background: z.string(),
                goals: z.string(),
                painPoints: z.array(z.string()),
                archetype: z.literal('Wildcard'),
            })
        }),
        prompt,
    });

    return { ...result.persona, id: `wildcard-${Date.now()}` };
};

export type Persona = {
    id: string;
    name: string;
    role: string;
    description: string;
    background: string;
    goals: string;
    painPoints: string[];
    archetype: string;
    avatar?: string;
};

export const simulateInterview = async (content: string, persona: Persona, apiKey: string, mode: ContentMode = 'standard') => {
    // MOCK MODE FOR TESTING
    if (apiKey === 'test-key' || apiKey === 'test-key-123' || (apiKey && apiKey.startsWith('test-') || apiKey.startsWith('AIzaSyDummy'))) {
        console.log('Using MOCK MODE for simulateInterview');
        await new Promise(resolve => setTimeout(resolve, 800));
        return {
            resonanceScore: Math.floor(Math.random() * 4) + 6, // Random score between 6 and 10
            summary: `This is a mock summary for ${persona.name}. The content was analyzed in test mode.`,
            strengths: ['Mock strength 1', 'Mock strength 2'],
            weaknesses: ['Mock weakness 1', 'Mock weakness 2'],
            confusionPoints: ['Mock confusion 1'],
            suggestions: ['Mock suggestion 1'],
            personaName: persona.name,
            personaRole: persona.role
        };
    }

    const model = getAIModel(apiKey);

    const basePrompt = `You are ${persona.name}, a ${persona.role}. 
  Background: ${persona.background}
  Goals: ${persona.goals}
  Background: ${persona.background}
  Goals: ${persona.goals}
  Pain Points: ${persona.painPoints.join(', ')}`;

    const standardQuestions = `
  Adopt your persona's mindset completely. Do not be polite; be brutally honest based on your specific background and pain points.

  **Phase 1: Visceral Reaction (System 1 Thinking)**
  - What is your immediate emotional response? (Bored, Intrigued, Confused, etc.)
  - What is the very first thing that caught your eye?

  **Phase 2: Cognitive Analysis (System 2 Thinking)**
  - **Clarity Check**: Highlight any specific sentence that feels jargon-heavy or vague.
  - **Skepticism Check**: Which claim do you doubt? Why?
  - **Value Check**: Does this actually help you achieve your Goals?

  **Phase 3: The 'Vibe Check'**
  - On a scale of 1-10, how much does this 'resonate' with your personal frequency?
  - If you had to describe this content to a peer using only emojis/slang, what would you use?
  - What is the strongest point for you?
  - What is the weakest point?`;

    const crisisQuestions = `
  Read the following content and provide your CRITICAL feedback.
  You are looking for reasons to criticize, misunderstand, or mock this content.
  Focus on:
  1. What is the worst possible interpretation of this text?
  2. Which phrases could be taken out of context to look bad?
  3. Does this sound tone-deaf, arrogant, or evasive?
  4. If you had to write a negative tweet/headline about this, what would it be?
  5. What triggers your skepticism?`;

    const prompt = `${basePrompt}

  ${mode === 'crisis' ? crisisQuestions : standardQuestions}

  Content:
  ${content.slice(0, 2000)}...
  `;

    const { object: feedback } = await generateObject({
        model,
        schema: z.object({
            resonanceScore: z.number().min(0).max(10),
            summary: z.string(),
            strengths: z.array(z.string()),
            weaknesses: z.array(z.string()),
            confusionPoints: z.array(z.string()),
            suggestions: z.array(z.string()),
        }),
        prompt,
    });

    return { ...feedback, personaName: persona.name, personaRole: persona.role };
};

export type InterviewResult = Awaited<ReturnType<typeof simulateInterview>>;

export const synthesizeReport = async (interviews: InterviewResult[], apiKey: string, mode: ContentMode = 'standard') => {
    // MOCK MODE FOR TESTING
    if (apiKey === 'test-key' || apiKey === 'test-key-123' || (apiKey && apiKey.startsWith('test-') || apiKey.startsWith('AIzaSyDummy'))) {
        console.log('Using MOCK MODE for synthesizeReport');
        await new Promise(resolve => setTimeout(resolve, 1500));
        return {
            executiveSummary: "This is a mock executive summary generated for testing purposes. The content appears to be well-structured but requires further refinement for specific audiences.",
            overallScore: 7.5,
            audienceAlignment: [
                { audience: "Tech Enthusiasts", alignmentScore: 8, keyTakeaway: "Strong technical depth." },
                { audience: "Business Leaders", alignmentScore: 6, keyTakeaway: "Needs more ROI focus." }
            ],
            topStrengths: ["Clear vision", "Innovative approach"],
            topWeaknesses: ["Lack of concrete examples", "Jargon usage"],
            actionableRecommendations: [
                { area: "Tone", suggestion: "Soften the language.", impact: "Medium" }
            ],
            soundbites: {
                positive: ["The future is now."],
                negative: ["This might be too risky."]
            },
            toneAnalysis: {
                defensiveness: 3,
                corporatespeak: 6,
                empathy: 7,
                clarity: 8
            },
            goNoGo: {
                decision: "GO",
                confidenceScore: 85,
                reasoning: "The content is solid and mocks are passing."
            }
        };
    }

    const model = getAIModel(apiKey);

    const prompt = `Analyze the following feedback from ${interviews.length} different personas.
  
  Synthesize the interview data using **Thematic Analysis**.
  1. **Pattern Recognition**: Identify recurring friction points across multiple personas.
  2. **Divergence Analysis**: Where do personas strongly disagree? (e.g. Techies love it, Executives hate it).
  3. **Segmented Insights**: Group findings by 'Psychographic' alignment.
  4. **Strategic Recommendations**: Provide actionable fixes using the 'Start, Stop, Continue' framework.

  Synthesize into a comprehensive ${mode === 'crisis' ? 'CRISIS RISK ASSESSMENT' : 'Resonance'} report.
  ${mode === 'crisis' ? 'Focus heavily on potential backlash, PR risks, and negative interpretations.' : 'Identify common patterns, conflicting opinions, and overall recommendations.'}

  Feedback Data:
  ${JSON.stringify(interviews, null, 2)}
  `;

    const { object: report } = await generateObject({
        model,
        schema: z.object({
            executiveSummary: z.string(),
            overallScore: z.number(),
            audienceAlignment: z.array(z.object({
                audience: z.string(),
                alignmentScore: z.number(),
                keyTakeaway: z.string(),
            })),
            topStrengths: z.array(z.string()),
            topWeaknesses: z.array(z.string()),
            actionableRecommendations: z.array(z.object({
                area: z.string(),
                suggestion: z.string(),
                impact: z.enum(['High', 'Medium', 'Low']),
            })),
            // New PR Fields
            soundbites: z.object({
                positive: z.array(z.string()).describe("Best quote-worthy phrases from the content"),
                negative: z.array(z.string()).describe("Most dangerous/clippable phrases that could be taken out of context")
            }),
            toneAnalysis: z.object({
                defensiveness: z.number().min(1).max(10).describe("1=Open, 10=Defensive"),
                corporatespeak: z.number().min(1).max(10).describe("1=Human, 10=Corporate Robot"),
                empathy: z.number().min(1).max(10).describe("1=Cold, 10=Empathetic"),
                clarity: z.number().min(1).max(10).describe("1=Confusing, 10=Crystal Clear")
            }),
            goNoGo: z.object({
                decision: z.enum(['GO', 'NO-GO', 'CAUTION']),
                confidenceScore: z.number().min(0).max(100),
                reasoning: z.string()
            })
        }),
        prompt,
    });

    return report;
};

export type FinalReport = Awaited<ReturnType<typeof synthesizeReport>>;
